---
title: "App Router 안 건드리고 멀티 리전 구현하기"
date: "2026-02-15"
description: "Next.js 미들웨어 rewrite로 App Router 변경 없이 멀티 리전을 구현한 방법. dynamic segment 대신 URL prefix 방식으로 관심사를 분리한 실전 사례."
tags: ["nextjs", "multi-region", "middleware", "system-design"]
published: true
---

## 같은 개념, 다른 단어

NZ 마켓에서 운영 중인 PTE(Private Training Establishment) 프로젝트가 있었다. 교육 기관이 커리큘럼을 관리하고, 학생 평가를 추적하는 시스템. 잘 돌아가고 있었다.

그러다 AU 마켓 진출이 결정됐다. 같은 도메인, 비슷한 규제 구조. 시스템을 그대로 가져다 쓸 수 있을 줄 알았다.

문제는 **용어**였다.

NZ에서 "standard"라고 부르는 개념을 AU에서는 "competency"라고 부른다. 의미는 같다. 하지만 AU 고객 앞에서 "standard"라는 단어를 쓰면 완전히 다른 뜻이 된다. 단순 번역이 아니라 **비즈니스 도메인 용어 자체가 리전마다 다른 상황**.

i18n으로 풀 수 있는 문제가 아니었다. 리전이라는 개념이 필요했다.

## 유저는 리전을 넘나든다

한 가지 더 복잡한 점. 한 유저가 NZ와 AU 양쪽에서 일할 수 있었다. NZ 기관에 소속되면서 동시에 AU 기관도 관리하는 케이스.

그래서 리전은 고정값이 아니라 **전환 가능한 컨텍스트**여야 했다. 유저가 쉽게 왔다 갔다 할 수 있어야 한다.

DB는 크게 문제가 안 됐다. Postgres 스키마에 리전 관련 컬럼을 추가하고, 쿼리에 필터를 거는 정도. 진짜 문제는 **라우팅**이었다.

## 선택지 1: `app/[region]/` — 단순하지만 단순하지 않다

Next.js App Router를 쓰고 있었다. 첫 번째로 떠오른 접근은 이랬다.

```
app/
  [region]/
    dashboard/
      page.tsx
    workspace-edu/
      ...
```

`[region]` dynamic segment를 최상위에 두고, layout에서 서버 사이드로 리전을 검증한다. 직관적이다.

하지만 파고 들어가면 문제가 보인다.

**모든 route에 리전이 강제된다.** `params.region`이 모든 page, 모든 layout에 전파된다. 리전과 아무 관계없는 admin 페이지, 설정 페이지도 다 region param을 받아야 한다. 타입 정의에도 들어간다. 전체 코드베이스에 노이즈가 생긴다.

**리전이 필요 없는 페이지를 어디에 둘 것인가.** `[region]` 밖에 따로 빼면 폴더 구조가 나뉜다. 안에 넣으면 의미 없는 리전 값을 들고 다닌다. 어느 쪽이든 지저분하다.

**기존 코드 전면 수정.** 모든 `Link` 컴포넌트, 모든 `redirect()` 호출에 region을 추가해야 한다. `generateStaticParams`도 전부 수정. 단순히 폴더를 옮기는 게 아니라 **코드 전체를 건드리는 작업**이다.

**빌드 성능.** `[region]`이 최상위에 있으면 모든 페이지가 dynamic route가 된다. static generation을 하려면 `generateStaticParams`에서 리전별로 전부 정적 경로를 생성해야 한다. 페이지가 많아지면 빌드 시간이 리전 수에 비례해서 늘어난다.

**nested dynamic segment 충돌.** 프로젝트에 이미 `[slug]`나 `[id]` 같은 dynamic segment가 있었다. 여기에 `[region]`이 최상위로 들어가면 `[region]/[something]/[id]` 같은 중첩 구조가 되면서 라우팅 우선순위가 복잡해진다. 디버깅할 때 "이 요청이 왜 이 route로 갔지?"를 추적하기 어려워진다.

**그리고 타이밍.** 팀원 전원이 `app/` 아래에서 동시에 작업하고 있었다. 모든 route 파일을 `[region]/` 폴더 아래로 이동시키는 순간, 진행 중인 모든 브랜치와 충돌이 난다. PR 하나 머지할 때마다 conflict resolve 지옥이 열리는 그림.

구조적으로도 의문이 있었고, 현실적으로도 불가능했다. 탈락.

## 선택지 2: 미들웨어에서 리전을 벗긴다

발상을 뒤집었다. 리전은 **모든 페이지의 관심사가 아니다.** 그러면 왜 모든 route에 리전을 강제하나?

URL은 `/nz/workspace-edu/dashboard`, `/au/workspace-edu/dashboard`처럼 리전을 포함한다. 하지만 미들웨어가 이 prefix를 벗겨내고 `/workspace-edu/dashboard`로 rewrite한다. 실제 app router 구조는 그대로.

```
요청:  /au/workspace-edu/dashboard
         ↓ middleware
rewrite: /workspace-edu/dashboard  +  x-locale: au
```

리전 정보는 `x-locale` 헤더로 주입한다. 리전별 용어가 필요한 컴포넌트만 이 헤더를 읽으면 된다. 나머지는 리전의 존재 자체를 모른다.

이건 차선책이 아니다. **관심사 분리**다.

## 구현의 핵심

미들웨어에서 하는 일은 크게 세 가지다.

**1. locale prefix 감지와 추출**

```typescript
const LOCALE_PATTERN = new RegExp(
  `^/(${SUPPORTED_LOCALES.join("|")})(\/.*)?$`
);
const localeMatch = pathname.match(LOCALE_PATTERN);
const locale = localeMatch?.[1];          // "nz" | "au"
const actualPathname = localeMatch?.[2] || "/";  // prefix 제거된 실제 경로
```

`SUPPORTED_LOCALES`는 중앙에서 관리한다. 새 리전이 추가되면 여기에 한 줄 추가하면 끝.

**2. 유저의 리전과 URL 리전 불일치 감지**

```typescript
if (locale && !isUrlLocaleMatchingSelected(token, locale)) {
  const userLocale = getUserLocaleFromToken(token);
  return NextResponse.redirect(
    new URL(`/${userLocale}${actualPathname}`, request.url)
  );
}
```

AU 유저가 `/nz/...` URL로 접근하면 자동으로 `/au/...`로 리다이렉트한다. 유저의 `selectedLocale`을 JWT에서 읽는다.

**3. rewrite + 헤더 주입**

```typescript
if (locale) {
  const url = request.nextUrl.clone();
  url.pathname = actualPathname;

  const rewriteResponse = NextResponse.rewrite(url);
  rewriteResponse.headers.set("x-locale", locale);
  return rewriteResponse;
}
```

여기서 마법이 일어난다. URL은 `/au/workspace-edu/dashboard`로 보이지만, 실제로 렌더링되는 건 `/workspace-edu/dashboard`. 리전 정보는 헤더로 전달된다.

## 이 방식이 좋았던 이유

**충돌 제로.** 기존 route 파일을 하나도 안 움직였다. 팀원들 브랜치에 영향 없음.

**점진적 적용.** 리전별 용어가 필요한 컴포넌트만 `x-locale` 헤더를 읽으면 된다. 나머지는 그대로.

**리전 추가가 쉽다.** `SUPPORTED_LOCALES`에 새 값 추가하고, matcher 패턴에 추가하면 끝. 폴더를 새로 파거나 파일을 복사할 필요 없다.

**유저 전환이 자연스럽다.** `selectedLocale`만 바꾸면 다음 요청부터 자동으로 해당 리전 URL로 리다이렉트된다.

## 트레이드오프

완벽한 방법은 없다.

`x-locale` 헤더에 의존하기 때문에, **서버 컴포넌트에서 리전 정보를 읽는 방법이 직관적이지 않다.** `params.region`으로 바로 접근하는 것과는 다르다. 헤더를 읽는 유틸리티 함수를 따로 만들어야 했다.

클라이언트 컴포넌트에서는 헤더를 직접 읽을 수 없다. 서버에서 props로 내려주거나 context로 감싸야 한다. 한 단계가 더 생긴다.

하지만 이건 **지금 팀이 멈추지 않는 것**과 바꾼 트레이드오프다. 받아들일 만했다.

## 결국은 제약 조건의 문제

`[region]` dynamic segment가 무조건 정석이라는 건 착각이다. 리전이 **모든 페이지의 관심사**일 때만 맞는 구조다. 리전별 용어가 필요한 페이지가 전체의 일부라면, 모든 route에 리전을 강제하는 건 오히려 과잉 설계다.

미들웨어 rewrite는 hacky한 방법이 아니다. **리전을 라우팅 레이어에서 처리하고, 각 페이지는 필요할 때만 리전을 인식한다.** 관심사 분리 원칙에 더 가깝다.

거기에 현실적 이점도 있었다. 팀이 멈추지 않았고, 기존 코드 변경이 최소화됐고, 새 리전 추가가 쉬워졌다.

시스템 디자인에서 "정석"은 상황에 따라 달라진다. 중요한 건 **왜 이 선택이 지금 이 상황에서 맞는지**를 설명할 수 있느냐다.